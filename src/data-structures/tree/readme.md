### tree

在计算机科学中, 树`tree`是一种广泛使用的抽象数据类型`ADT`— 或实现此`ADT`的数据结构 — 模拟分层树结构, 具有根节点和有父节点的子树,表示为一组链接节点。

树可以被(本地地)递归定义为一个(始于一个根节点的)节点集, 每个节点都是一个包含了值的数据结构, 除了值,还有该节点的节点引用列表(子节点)一起。 树的节点之间没有引用重复的约束。


### tree的基本概念

![tree-basic](https://cdn.jsdelivr.net/gh/staticImages/img@v1/coding/algorithm/tree-basic.jpg)

- **根节点**： 位于树顶部的节点，它没有父节点
- **节点**： 树中的每个元素都叫节点。一个节点可以有祖先和后代。
- **内部节点**： 至少有一个子节点的节点成为内部节点。如图中的（5，7，9，,5，,13，,20）
- **外部节点**： 没有子元素的节点成为外部节点或者叶子节点，如图中的（3、6、8、10、12、14、18和25）
- **子树**： 子树由节点和它的后代构成，如节点13、12和14构成了上图中树的一棵子树
- **深度**： 节点的一个属性是深度，节点的深度取决于它的祖先节点数量。比如，节点3有三个祖先节点（5，7，11），其深度为3
- **树的高度**： 树的高度取决于所有节点深度的最大值。一棵树可以分成层级。根节点在第0层。它的子节点在第1层，以此类推。

### 二叉树

二叉树中的节点最多只有两个子节点：一个是左侧子节点，另一个是右侧子节点。这个定义有助于我们写出更高效地在树中插入、查找和删除节点的算法。二叉树在计算机科学中应用非常广泛。

### 二叉搜索树（BST）

二叉搜索树是二叉树的一种，只允许在左侧节点存储比父节点小的值，在右侧节点存储比父节点大的值。

### 自平衡树(AVL)

`BST`存在一个问题：取决于你添加的节点数，树的一条边可能会非常深；也就是说，树的一条分支会有很多层，而其他的分支却只有几层。这会在需要在某条边上添加、移除和搜索某个节点时引起一些性能问题。为了解决这个问题，有一种树叫作`Adelson-Velskii-Landi`树（`AVL`树）。`AVL`树是一种自平衡二叉搜索树，意思是任何一个节点左右两侧子树的高度之差最多为`1`。

在AVL树中，需要对每个节点计算右子树高度（hr）和左子树高度（hl）之间的差值，该值（hr－hl）应为0、1或-1。如果结果不是这三个值之一，则需要平衡该AVL树。这就是平衡因子的概念。

平衡操作--AVL旋转

- 左-左（LL）：向右的单旋转
- 右-右（RR）：向左的单旋转
- 左-右（LR）：向右的双旋转（先LL旋转，再RR旋转）
- 右-左（RL）：向左的双旋转（先RR旋转，再LL旋转）

![Tree_Rebalancing](https://cdn.jsdelivr.net/gh/staticImages/img@v1/coding/algorithm/Tree_Rebalancing.png)

### 树的遍历

- 中序遍历

中序遍历是一种以上行顺序访问BST所有节点的遍历方式，也就是以从最小到最大的顺序访问所有节点。中序遍历的一种应用就是对树进行排序操作。

![tree-ordertraverse](https://cdn.jsdelivr.net/gh/staticImages/img@v1/coding/algorithm/tree-ordertraverse.jpg)

- 先序遍历

先序遍历是以优先于后代节点的顺序访问每个节点的。先序遍历的一种应用是打印一个结构化的文档

![tree-pre-order-traverse](https://cdn.jsdelivr.net/gh/staticImages/img@v1/coding/algorithm/tree-pre-order-traverse.jpg)

- 后序遍历

后序遍历则是先访问节点的后代节点，再访问节点本身。后序遍历的一种应用是计算一个目录及其子目录中所有文件所占空间的大小。

![tree-post-order-traverse](https://cdn.jsdelivr.net/gh/staticImages/img@v1/coding/algorithm/tree-post-order-traverse.jpg)