### 计数排序

计算排序的时间复杂度是`O(n)`,只能用在数据范围不大的场景中。如果数据范围K比要排序的数据n大很多，就不适合用计数排序了。计数排序只能给非负整数排序，如果要排序的数据是其他类型的，要将其在不改变相对大小的情况下转化为非负整数。如：小数都乘以10、数据范围在[-1000, 1000]之间的对每个数都加1000转化为非负整数。

计数排序算法如下：

#### 步骤 1

- 遍历数组A，获取最大值
- 根据最大值，创建数组C
- 再次遍历A，将每个值的计算存入C中

![step1](https://user-images.githubusercontent.com/6022948/58634345-a9594180-831d-11e9-8a01-5eaa67553878.gif)

#### 步骤 2

- 将计数数组C顺序求和，即C[0] = C[0], C[1] = C[0] + C[1], C[2] = C[2] + C[1].... C[n] = C[n] + C[n -1]  
- 完成之后，C[K] 的值表示K出现的次数

![step2](https://user-images.githubusercontent.com/6022948/58634346-a9f1d800-831d-11e9-9f45-d87ffd5771c1.png)

#### 步骤 3

- 再次遍历A数组
- 假设当扫描到元素3时候， 此时C[3] = 7 说明A数组中 < 3的有7个，也就是说3是数组B中的第7个元素（也就是数组B中下标6的位置）
- 当3放入到数组B中后，< 3的元素就只剩下6个了，因此对应的C[3] 要减1，即值变成6

![step3](https://user-images.githubusercontent.com/6022948/58634347-a9f1d800-831d-11e9-884d-869d4b42473e.gif)
